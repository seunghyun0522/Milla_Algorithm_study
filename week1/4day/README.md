# 💡**문제**

- 브루트포스
- 앉았다

[문제링크](https://www.acmicpc.net/problem/14717)

# 💡**문제 분석 요약**

문제 조건 :

- 1~10이 쓰인 카드 각 2장씩 총 20장
- 강한 족보의 패를 가진 사람이 이긴다.
- 족보
  - 0땡: 두 패가 모두 10
  - 9땡: 두 패가 모두 9
  - ...
  - 2땡: 두 패가 모두 2
  - 1땡: 두 패가 모두 1
  - 9끗: 땡이 아니고, 두 패를 더했을 때 일의 자리의 수가 9
  - 8끗: 땡이 아니고, 두 패를 더했을 때 일의 자리의 수가 8
  - ...
  - 1끗: 땡이 아니고, 두 패를 더했을 때 일의 자리의 수가 1
  - 0끗: 땡이 아니고, 두 패를 더했을 때 일의 자리의 수가 0
-

# 💡**알고리즘 설계**

- 먼저 2장을 챙겼으니 20-2 =18장의 랜덤 카드를 가져올 경우의 수를 생각해야했다
  - 18C2 = 153 이 caseData
- 땡일 경우에는 경우의 수가 땡마다 1개밖에 없기때문에 간단하게 계산해준다.
- 끗일 경우에는 따로 다른 끗이 나올 수 있는 경우의 수를 계산해준다.
  - 값이 같을 때는 경우의 수를 2 증가해주고 다를 경우에는 4를 증가해준다.

# 💡코드

```jsx
const input = (
  process.platform == "linux"
    ? require("fs").readFileSync("/dev/stdin").toString()
    : require("fs").readFileSync("./ex.txt").toString()
)
  .trim()
  .split("\n");

let [a, b] = input[0].split(" ").map(Number);

let caseData = 153;
let sum = 0;
let result;
if (a === b) {
  result = (caseData - (10 - a)) / caseData;
  console.log(result.toFixed(3));
} else {
  let cnt = 0;
  for (let i = 1; i <= 10; i++) {
    for (let j = i + 1; j <= 10; j++) {
      sum = i + j;
      if (sum % 10 < (a + b) % 10) {
        if (i === a || i === b || j === a || j === b) cnt += 2;
        else cnt += 4;
      }
    }
  }
  result = cnt / caseData;
  console.log(result.toFixed(3));
}
```

# 💡시간복잡도

O(n^2)

# 💡 틀린 이유

처음에 고려했을 때 전체 경우의 수를 생각하지 않았다.

(1,3) , (2,2) (3,1) 이런식으로 다 계산으로 했어야 했는데 반복되는 것들은 제외시켰다.

# 💡 틀린 부분 수정 or 다른 풀이

# 💡 느낀점 or 기억할정보

점점 문제가 어려워지고 있고 생각만 하면 풀 수 있는데 생각이 너무 어려웠다.

아직까지 다른 레퍼런스들을 종종 참고하고 해설을 보지않고 힌트만 얻으려고 하는데 이 방법이 시간 대비에 비효율적이라는 생각이 조금 들었다.. 인증에 집중하기보다는 문제를 더 신중하고 오래 고민할 수 있도록 노력해야겠다.
